syntax = "proto3";

option java_multiple_files = true;
option java_package = "io.mubel.api.grpc";
option java_outer_classname = "EventsProto";
package events;

message MetaData {
  map<string, string> data = 1;
}

/*
An "event" is a data record expressing an occurrence and its context.
 */
message EventDataInput {
  string id = 1; // Id of the event - REQUIRED
  string streamId = 2; // The id of the event stream / entity - REQUIRED
  uint32 version = 3; // version of the event in the event stream - REQUIRED
  string type = 5; // Type of event - REQUIRED
  MetaData metaData = 6; // Meta data for the event
  bytes data = 7; // event data
}

/*
An "event" is a data record expressing an occurrence and its context.
Events will contain two types of information: the Event Data representing the Occurrence and Context metadata providing contextual information about the Occurrence.
 */
message EventData {
  string id = 1; // Id of the event - REQUIRED
  string streamId = 2; // The id of the event stream / entity - REQUIRED
  uint32 version = 3; // version of the event in the event stream - REQUIRED
  string type = 4; // Type of event - REQUIRED
  int64 createdAt = 5; // Timestamp in
  int64 sequenceNo = 6; // The unique sequence number for this event
  MetaData metaData = 7; // Meta data for the event
  bytes data = 8; // event data
}
/**
 Request mainly used for appending events to an event store.
 This request can also be used to schedule events for publication at a later time or to cancel scheduled events.
 */
message AppendRequest {
  // The name of the event store to append to. REQUIRED.
  string esid = 1;
  // The events to append to the event store.
  repeated EventDataInput event = 2;
  // Optional list of events to schedule for publication at a later time.
  repeated ScheduledEvent scheduledEvent = 3;
  // Optional list of scheduled event id's to cancel.
  repeated string cancelId = 4;
  // Optional request id, if specified a request with the same id will be ignored.
  string requestId = 5;
}

message GetEventsRequest {
  // required
  string esid = 1;
  // result will only contain events for this stream id if specified
  string streamId = 2;
  // only effective when stream id is specified
  uint32 fromVersion = 3;
  // only effective when stream id is specified
  uint32 toVersion = 4;
  // max size of the result list (default 999)
  uint32 size = 5;
  // return events created after the sequence no, only effective if stream id has not been specified
  int64 fromSequenceNo = 6;
}

message SubscribeRequest {
  string esid = 1;
  int64 fromSequenceNo = 2;
  string consumerGroupToken = 3;
}

message GetEventsResponse {
  string streamId = 1;
  uint32 size = 2;
  repeated EventData event = 3;
}

enum DataFormat {
  OTHER = 0;
  PROTO = 1;
  JSON = 2;
}

message ProvisionEventStoreRequest {
  // The name of the event store to provision.
  string esid = 1;
  // The payload type of the events to store
  DataFormat dataFormat = 2;
  // if true, the call will block until the event store is open
  // if false, the call will return immediately and the event store will be opened in the background
  bool waitForOpen = 3;
  // The name of the storage backend to use for the event store.
  string storageBackendName = 4;
}

message DropEventStoreRequest {
  string esid = 1;
}

message DropEventStoreResponse {
  string esid = 1;
}

message EventStoreDetails {
  string esid = 1;
  string type = 2;
  DataFormat dataFormat = 3;
}

message GetEventStoreSummaryRequest {
  string esid = 1;
}

message EventStoreSummary {
  string esid = 1;
  uint64 eventCount = 2;
  uint64 streamCount = 3;
}

message AppendAck {
  string message = 1;
}

message ProblemDetail {

  // A URI reference that identifies the problem type
  // @format uri
  string type = 1;
  // A short, human-readable summary of the problem type
  string title = 2;
  // The gRPC status code generated by the origin server for this occurrence of the problem
  uint32 status = 3;
  // A human-readable explanation specific to this occurrence of the problem
  string detail = 4;
}

message GetServiceInfoRequest {

}

message StorageBackendInfo {
  string name = 1;
  string type = 2;
}

message ServiceInfoResponse {
  repeated StorageBackendInfo storageBackend = 1;
  repeated EventStoreDetails eventStore = 2;
}

/**
 A scheduled event is an event that will be published at a specific time in the future.

 Scheduled events can be used in two modes:
 1. As a normal event that will be stored in the event stream
 2. As a deadline event that will not be stored in the event stream but will be used to trigger a deadline

 Deadline events are not handled by the event store and will not be present in the event stores various services
 such as subscriptions etc.

 Scheduled events are useful for triggering events at a specific time in the future, for example handling timout or triggering
 of various business processes.
*/
message ScheduledEvent {
  // Id of the event - REQUIRED
  string id = 1;
  // If specified the event will be published to the specified stream when the event is triggered
  string streamId = 2;
  // Use this to specify the target entity when the scheduled event should act as a deadline.
  // i.e. the it should not be stored as an event in the event stream.
  string targetEntityId = 3;
  // The type of the target entity - REQUIRED
  string targetType = 4;
  // Indicates if the event should be treated as a deadline event. If true, the event will not be stored in the event stream.
  bool deadline = 5;
  // The category of the event, can be used for filtering
  string category = 6;
  // The time in milliseconds since the epoch (UTC) when the event should be published - REQUIRED
  uint64 publishTime = 7;
  // Meta data for the event
  MetaData metaData = 8;
  // Type of event data - REQUIRED if data is specified
  string type = 9;
  // event data - optional
  bytes data = 10;

}

// Cancel a scheduled event. The event will not be published.
message CancelScheduledEventsRequest {
  // Ids of the events to cancel - REQUIRED
  repeated string eventId = 1;
}

// Subscribe to scheduled events. The subscriber will receive events when they are published.
message ScheduledEventsSubscribeRequest {
  string consumerGroup = 1;
  // the categories to subscribe to. If empty, all categories will be subscribed to
  repeated string category = 2;
  string consumerGroupToken = 3;
}

// Contains events that have been triggered.
message TriggeredEvents {
  repeated ScheduledEvent event = 1;
}

message Heartbeat {
  int64 timestamp = 1;
}

message JoinConsumerGroupRequest {
  string esid = 1;
  string consumerGroup = 2;
}

message LeaveConsumerGroupRequest {
  string token = 1;
}

message ConsumerGroupStatus {
  string groupId = 1;
  string token = 2;
  bool leader = 3;
}

message CopyEventsRequest {
  string sourceEsid = 1;
  string targetEsid = 2;
}

enum JobState {
  UNKNOWN = 0;
  RUNNING = 1;
  COMPLETED = 2;
  FAILED = 3;
}

message GetJobStatusRequest {
  string jobId = 1;
}

message JobStatus {
  string jobId = 1;
  JobState state = 2;
  string description = 3;
  // Problem detail if state is FAILED
  ProblemDetail problem = 4;
  // progress in percent
  uint32 progress = 5;
  uint64 updatedAt = 6;
  uint64 createdAt = 7;
}